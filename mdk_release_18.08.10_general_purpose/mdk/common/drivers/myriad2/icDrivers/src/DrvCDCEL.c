///
/// @file
/// @copyright All code copyright Movidius Ltd 2012, all rights reserved.
///            For License Warranty see: common/license.txt
///
/// @brief     IC Driver for the External PLL CDCE913PW
///
///
///

// 1: Includes
// ----------------------------------------------------------------------------
#include "mv_types.h"
#include "DrvCDCEL.h"
#include "assert.h"
#include "DrvTimer.h"

#include <DrvCdcelConfigs.h>

// 2:  Source Specific #defines and types  (typedef,enum,struct)
// ----------------------------------------------------------------------------

#define CDCEL913_ADDR_CLK_GEN_8BW   (0xCA)
#define CDCEL913_ADDR_CLK_GEN_8BR   (CDCEL913_ADDR_CLK_GEN_8BW |  1)
#define CDCEL913_ADDR_CLK_GEN_7B    (CDCEL913_ADDR_CLK_GEN_8BW >> 1)

// defines for CDCEL925PW (different slave address, but mainly same registers)

#define CDCEL925_ADDR_CLK_GEN_8BW   (0xC8)
#define CDCEL925_ADDR_CLK_GEN_8BR   (CDCEL925_ADDR_CLK_GEN_8BW |  1)
#define CDCEL925_ADDR_CLK_GEN_7B    (CDCEL925_ADDR_CLK_GEN_8BW >> 1)


#define IC_PLL_DEBUG

#ifdef IC_PLL_DEBUG
#include <stdio.h>
#define PLL_DPRINTF(...)  printf(__VA_ARGS__)
#else
#define PLL_DPRINTF(...) // (void(*)())(__VA_ARGS__)
#endif

#define PLL_VERIFY_REGISTER_WRITES 1

// 3: Global Data (Only if absolutely necessary)
// ----------------------------------------------------------------------------
static u32 CDCEL_I2C_ADDR;

// 4: Static Local Data
// ----------------------------------------------------------------------------
// 5: Static Function Prototypes
// ----------------------------------------------------------------------------
void DrvI2cMWriteByte(I2CM_Device * dev,u32 slaveAddr,u32 regAddr, u8 value);
u8   DrvI2cMReadByte(I2CM_Device * dev,u32 slaveAddr,int regAddr);
// 6: Functions Implementation
// ----------------------------------------------------------------------------

static int CDCELConfigure(I2CM_Device * dev, u32 config_index)
{
    int i, j;
    int retval = 0;
    int size;
    const config_element_type * pCfg;
    u8 readBackValue;
    UNUSED(readBackValue); // avoid 'unused variable' error from scan build
    switch (config_index)
        {
        case EXT_PLL_CFG_74MHZ:
            pCfg = icExtPllCfg_74MHz;
            size = sizeof(icExtPllCfg_74MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_111MHZ:
            pCfg = icExtPllCfg_111MHz;
            size = sizeof(icExtPllCfg_111MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_148MHZ:
            pCfg = icExtPllCfg_148MHz;
            size = sizeof(icExtPllCfg_148MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_74_24_24MHZ:
            pCfg = icExtPllCfg_74_24_24MHz;
            size = sizeof(icExtPllCfg_74_24_24MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_148_24_24MHZ:
            pCfg = icExtPllCfg_148_24_24MHz;
            size = sizeof(icExtPllCfg_148_24_24MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_74_24_16MHZ:
            pCfg = icExtPllCfg_74_24_16MHz;
            size = sizeof(icExtPllCfg_74_24_16MHz) / sizeof(config_element_type);
            break;
        case EXT_PLL_CFG_148_37MHZ:
            pCfg = icExtPllCfg_148_37MHz;
            size = sizeof(icExtPllCfg_148_37MHz) / sizeof(config_element_type);
            break;

        default:
            retval = -1;
            assert(retval != -1);
            return retval;
        }

    for (i = 0; i < size; ++i)
    {
        // We program the device in byte mode rather than block mode
        /// @TODO: Potential future optimisation. Enable block mode
        (void)DrvI2cMWriteByte(dev, CDCEL_I2C_ADDR,
                               pCfg[i].address | SELECT_BYTE_ACCESS,
                               pCfg[i].value);
    }


#ifdef PLL_VERIFY_REGISTER_WRITES
    // Verify the registers we wrote
    for (i = 0; i < size; ++i)
    {
        // The three reads below are a really nasty hack to work around a problem
        // which is believed to be internal to the PLL
        // Previously when reading back the configuration of the PLL intermittent
        // errors were observed. No evidence was found to suggest that the problem
        // was due to I2C signal quality, but rather it was suspected that the
        // issue relates to delays within the chip itself.
        // By reading the value 3 times we effecively introduce a delay between byte
        // reads. Given than the last value is alway correct we can assume that the
        // chip is indeed correctly configured.
        // TODO: It would be nice to better analyse the pll register set and see if
        // we can find the reason for this issue. Unfortunately the reg config
        // is generated by a software wizard and we don't have good docs on all
        // the registers
        for (j = 0; j < 3; j++)
          readBackValue = DrvI2cMReadByte(dev, CDCEL_I2C_ADDR,
                                          pCfg[i].address | SELECT_BYTE_ACCESS);
        if (readBackValue != pCfg[i].value)
        {
            printf("\nExternal PLL on I2C reg %02X, %02X was written  but %02X was read\n",(int) pCfg[i].address, (int) pCfg[i].value, (int)readBackValue);
            retval++;
            assert(retval == 0);
        }
    }
#endif
    //TODO: change temporary sleep workaround to a I2C poll. See Bug 17390 - SDK - PLL settings in the icPllCDCE913 driver
    DrvTimerSleepMs(500);

    return retval;
}

int CDCE913Configure(I2CM_Device * dev, u32 config_index)
{
    CDCEL_I2C_ADDR = CDCEL913_ADDR_CLK_GEN_7B;
    return CDCELConfigure(dev, config_index);
}


int CDCE925Configure(I2CM_Device * dev, u32 config_index)
{
    CDCEL_I2C_ADDR = CDCEL925_ADDR_CLK_GEN_7B;
    return CDCELConfigure(dev, config_index);
}
