////// @file lumaFusionFp16ToFp16.cpp/// @copyright All code copyright Movidius Ltd 2012, all rights reserved///            For License Warranty see: common/license.txt////// @brief ///#include "lumaFusionFp16ToFp16.h"#include <math.h>#include <stdlib.h>#include <stdio.h>half genAlphaFp16(half lumaShort, half lslope1, half lslope2){    half slope = 1/(lslope2-lslope1);    half alphaHalf;    alphaHalf = (lumaShort - lslope1) * slope;    if(lumaShort < lslope1)        alphaHalf = (half)1.0f;    else if(lumaShort < lslope2)        alphaHalf = (1.0f-alphaHalf);    else        alphaHalf = 0.0f;    return alphaHalf;}void mvispLumaFusionFp16ToFp16(half* inLumaShort, half* inLumaLong, half* outputAlpha, half* outputLumaFusion, u32 width, LumaFusionParam *params){    half alpha;    u32 i;    half expRat     = (half)params->expRat;    half lslope1    = (half)params->lslope1;    half lslope2    = (half)params->lslope2;    half eps        = (half)params->eps;    half temp;    for(i = 0; i < width; i++) {        inLumaShort[i] = inLumaShort[i] * expRat;        alpha = genAlphaFp16(inLumaShort[i], lslope1, lslope2);                outputLumaFusion[i] = inLumaLong[i] * alpha + inLumaShort[i]*(1-alpha);        outputLumaFusion[i] = outputLumaFusion[i] / expRat;                //needed to be performed before Gauss path        //so that's why it is also included in the lumaFusion filter        temp = eps + outputLumaFusion[i] * expRat;				        outputLumaFusion[i] = __builtin_shave_sau_log2_f16_l_r(temp) * (half)0.69314718056;                outputAlpha[i] = alpha;    }}